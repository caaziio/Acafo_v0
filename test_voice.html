<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Input Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
        }
        .voice-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 12px 24px;
            background: #dbeafe;
            color: #1d4ed8;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .voice-btn:hover {
            background: #bfdbfe;
        }
        .voice-btn.recording {
            background: #fee2e2;
            color: #dc2626;
        }
        .voice-status {
            display: none;
            margin: 20px 0;
            padding: 16px;
            background: #eff6ff;
            border: 1px solid #bfdbfe;
            border-radius: 8px;
        }
        .recording-indicator {
            width: 12px;
            height: 12px;
            background: #dc2626;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        textarea {
            width: 100%;
            height: 200px;
            padding: 16px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 16px;
            resize: none;
        }
        .countdown {
            font-family: monospace;
            font-size: 18px;
            color: #1d4ed8;
        }
    </style>
</head>
<body>
    <h1>Voice Input Test</h1>
    
    <div>
        <button id="voiceBtn" class="voice-btn">
            <svg id="micIcon" width="20" height="20" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4zm4 10.93A7.001 7.001 0 0017 8a1 1 0 10-2 0A5 5 0 015 8a1 1 0 00-2 0 7.001 7.001 0 006 6.93V17H6a1 1 0 100 2h8a1 1 0 100-2h-3v-2.07z" clip-rule="evenodd"></path>
            </svg>
            <span id="voiceBtnText">Voice Input</span>
        </button>
    </div>
    
    <div id="voiceStatus" class="voice-status">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div style="display: flex; align-items: center; gap: 8px;">
                <div id="recordingIndicator" class="recording-indicator"></div>
                <span id="recordingText">Recording...</span>
            </div>
            <div id="countdown" class="countdown">01:00</div>
        </div>
        <p style="margin-top: 8px; font-size: 14px; color: #1d4ed8;">
            Max 1 minute. Your words will appear in the box below.
        </p>
    </div>
    
    <div style="margin: 20px 0;">
        <label for="output">Transcribed Text:</label>
        <textarea id="output" placeholder="Your voice input will appear here..."></textarea>
    </div>
    
    <div style="margin: 20px 0;">
        <h3>Browser Support:</h3>
        <p>Web Speech API: <span id="speechSupport">Checking...</span></p>
        <p>MediaRecorder: <span id="mediaRecorderSupport">Checking...</span></p>
    </div>

    <script>
        const voiceBtn = document.getElementById('voiceBtn');
        const voiceBtnText = document.getElementById('voiceBtnText');
        const voiceStatus = document.getElementById('voiceStatus');
        const recordingIndicator = document.getElementById('recordingIndicator');
        const recordingText = document.getElementById('recordingText');
        const countdown = document.getElementById('countdown');
        const micIcon = document.getElementById('micIcon');
        const output = document.getElementById('output');
        const speechSupport = document.getElementById('speechSupport');
        const mediaRecorderSupport = document.getElementById('mediaRecorderSupport');

        // Check browser support
        const isSpeechRecognitionSupported = 'SpeechRecognition' in window || 'webkitSpeechRecognition' in window;
        const isMediaRecorderSupported = 'MediaRecorder' in window;
        
        speechSupport.textContent = isSpeechRecognitionSupported ? '✅ Supported' : '❌ Not Supported';
        mediaRecorderSupport.textContent = isMediaRecorderSupported ? '✅ Supported' : '❌ Not Supported';

        // Voice recording variables
        let isRecording = false;
        let recordingTimeout = null;
        let countdownInterval = null;
        let timeLeft = 60;
        let recognition = null;
        let mediaRecorder = null;
        let audioChunks = [];

        function startCountdown() {
            timeLeft = 60;
            countdown.textContent = '01:00';
            
            countdownInterval = setInterval(() => {
                timeLeft--;
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                countdown.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                if (timeLeft <= 0) {
                    stopRecording();
                }
            }, 1000);
        }

        function stopCountdown() {
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
        }

        function showRecordingUI() {
            voiceStatus.style.display = 'block';
            voiceBtn.classList.add('recording');
            voiceBtnText.textContent = 'Stop Recording';
            micIcon.classList.add('animate-pulse');
            isRecording = true;
        }

        function hideRecordingUI() {
            voiceStatus.style.display = 'none';
            voiceBtn.classList.remove('recording');
            voiceBtnText.textContent = 'Voice Input';
            micIcon.classList.remove('animate-pulse');
            isRecording = false;
        }

        function appendToTextarea(text) {
            const currentText = output.value;
            const separator = currentText && !currentText.endsWith(' ') && !currentText.endsWith('\n') ? ' ' : '';
            output.value = currentText + separator + text;
            
            // Scroll to bottom
            output.scrollTop = output.scrollHeight;
        }

        function stopRecording() {
            if (!isRecording) return;
            
            isRecording = false;
            hideRecordingUI();
            stopCountdown();
            
            if (recordingTimeout) {
                clearTimeout(recordingTimeout);
                recordingTimeout = null;
            }
            
            if (isSpeechRecognitionSupported && recognition) {
                recognition.stop();
            } else if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }
        }

        function startWebSpeechRecording() {
            try {
                recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
                recognition.continuous = true;
                recognition.interimResults = true;
                recognition.lang = 'en-US';
                
                let finalTranscript = '';
                
                recognition.onresult = (event) => {
                    let interimTranscript = '';
                    
                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const transcript = event.results[i][0].transcript;
                        if (event.results[i].isFinal) {
                            finalTranscript += transcript;
                        } else {
                            interimTranscript += transcript;
                        }
                    }
                    
                    // Update textarea with interim results
                    if (interimTranscript) {
                        const currentText = output.value;
                        const baseText = currentText.replace(finalTranscript, '');
                        output.value = baseText + finalTranscript + interimTranscript;
                    }
                };
                
                recognition.onend = () => {
                    if (isRecording) {
                        if (finalTranscript) {
                            appendToTextarea(finalTranscript);
                        }
                        stopRecording();
                    }
                };
                
                recognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                    if (event.error === 'not-allowed') {
                        alert('Microphone permission denied. Please allow microphone access and try again.');
                    } else {
                        alert('Speech recognition error: ' + event.error);
                    }
                    stopRecording();
                };
                
                recognition.start();
                showRecordingUI();
                startCountdown();
                
                recordingTimeout = setTimeout(() => {
                    stopRecording();
                }, 60000);
                
            } catch (error) {
                console.error('Speech recognition not supported:', error);
                startMediaRecorderRecording();
            }
        }

        function startMediaRecorderRecording() {
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(stream => {
                    mediaRecorder = new MediaRecorder(stream, {
                        mimeType: 'audio/webm;codecs=opus'
                    });
                    
                    audioChunks = [];
                    
                    mediaRecorder.ondataavailable = (event) => {
                        audioChunks.push(event.data);
                    };
                    
                    mediaRecorder.onstop = async () => {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        
                        // Stop all tracks
                        stream.getTracks().forEach(track => track.stop());
                        
                        // For testing, just show that we recorded audio
                        appendToTextarea('[Audio recorded - would send to server for transcription]');
                    };
                    
                    mediaRecorder.onerror = (event) => {
                        console.error('MediaRecorder error:', event);
                        alert('Recording error occurred. Please try again.');
                        stream.getTracks().forEach(track => track.stop());
                        stopRecording();
                    };
                    
                    mediaRecorder.start();
                    showRecordingUI();
                    startCountdown();
                    
                    recordingTimeout = setTimeout(() => {
                        stopRecording();
                    }, 60000);
                    
                })
                .catch(error => {
                    console.error('Microphone access error:', error);
                    if (error.name === 'NotAllowedError') {
                        alert('Microphone permission denied. Please allow microphone access and try again.');
                    } else {
                        alert('Failed to access microphone: ' + error.message);
                    }
                });
        }

        // Voice button click handler
        voiceBtn.addEventListener('click', () => {
            if (isRecording) {
                stopRecording();
            } else {
                if (isSpeechRecognitionSupported) {
                    startWebSpeechRecording();
                } else {
                    startMediaRecorderRecording();
                }
            }
        });
    </script>
</body>
</html>
